#!/usr/bin/env ruby

require 'thor'
require 'nessus-client'
require 'yaml'
require 'uri'
require 'date'
require 'terminal-table'

class Nessus < Thor

  # Thor thinks its a good idea to not exit(1) when something bad
  # happens, like bad command line arguments.  We disagree.
  def self.exit_on_failure?
    true
  end

  CREDS_FILE = ".nessus.yml"

  @@creds = nil

  no_commands do

    # Common workflow Thor options
    def self.common_options
      method_option :home, :type => :string, :default => ENV['HOME'], :desc => 'Home directory location for credentials file'
    end

    def self.common_list_options
      method_option :columns, :aliases => '-c', :type => :array, :default => ['id', 'name'], :desc => 'List of columns to display in a table'
    end

    def self.creds(home)
      unless @@creds
        creds_file = File.join(home, CREDS_FILE)
        file ("Missing file #{creds_file}") unless File.exist?(creds_file)
        @@creds = YAML.load(File.read(creds_file))
        ['url', 'secretKey', 'accessKey'].each do |key|
          fail("Missing #{key} value in #{creds_file}") unless @@creds[key]
        end
      end
      @@creds
    end

    # Display a table to the user. The provided block should an Array of
    # row values.
    #
    # @param enum [Enumerator]
    # @param cols [Array]
    #   List of column headers.
    # @param title [String]
    #   Optional table title.
    # @yield elem [Object]
    #   The current object in the enumeration.
    # @return nil
    def self.table_for(enum, cols, title = nil)
      rows = []
      enum.each do |elem|
        rows << yield(elem)
      end

      puts Terminal::Table.new(
        :title => title,
        :headings => cols,
        :rows => rows,
        :style => {
          :border_x => '-',
          :border_y => '',
          :border_i => '',
          :padding_left => 0,
          :padding_right => 2
        })
    end
  end

  desc "get-api-key NESSUS_URL", "Use username and password (interactive prompt) to generate an API key for Nessus and save to #{CREDS_FILE}"
  method_option :yes, :aliases => '-y', :type => :boolean, :desc => 'Skip prompts for confirmation'
  self.common_options
  def get_api_key(nessus_url)
     uri = URI(nessus_url)
     fail("You nees to use a https:// URL for Nessus") unless uri.scheme == 'https'
     creds_file = File.join(options[:home], CREDS_FILE)
     if File.exist?(creds_file) && !options[:yes]
       confirm = ask("Overwrite existing file #{creds_file} ?", :yellow, limited_to: ['yes', 'no'], :default => 'yes')
       if confirm != 'yes'
         say("Aborting command", :red)
         exit
       end
     end
     username = ask("username:")
     password = ask("password:", :echo => false)
     say('********')
     session = NessusClient::Session.create(nessus_url, username, password)
     keys = session.keys
     keys = {'url' => nessus_url}.merge(keys)
     File.write(creds_file, keys.to_yaml)
     say("New API keys written to #{creds_file}")
     session.destroy
  end

  class Scans < Thor
    desc "scans list", "List scans since a given date"
    method_option :home, :type => :string, :default => ENV['HOME'], :desc => 'Home directory location for credentials file'
    method_option :folder_id, :type => :numeric, :desc => "Folder ID"
    method_option :since, :desc => "Last modification date. Show only scans changed since then. Default 7 days."
    Nessus.common_list_options
    Nessus.common_options
    def list
      creds = Nessus.creds(options[:home])
      params = {}
      if options[:since]
         since = DateTime.parse(options[:since]).to_time.to_i
      else
        # Default to 7 days ago.
        since = Time.now.to_i - (7 * 24 * 3600)
      end
      params['last_modification_date'] = since
      if options[:folder_id]
        params = options[:folder_id]
      end
      client = NessusClient.new(creds['url'], creds['accessKey'], creds['secretKey'])
      result = client.get('/scans', params)
      Nessus.table_for(result['scans'], options['columns'], "Scans since #{Time.at(since).to_s}") do |scan|
        options['columns'].map { |column| scan[column] }
      end
    end
  end

  desc "scans", "Scan related commands"
  subcommand 'scans', Nessus::Scans

end

begin
  Nessus.start
rescue => e
  puts "ERROR - " + e.message
  puts e.backtrace.first
  exit(1)
end
