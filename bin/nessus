#!/usr/bin/env ruby

require 'nessus-client'
require 'yaml'
require 'uri'

class Nessus < Thor

  # Thor thinks its a good idea to not exit(1) when something bad
  # happens, like bad command line arguments.  We disagree.
  def self.exit_on_failure?
    true
  end

  @@creds = nil

  desc "get-api-key NESSUS_URL", "Use username and password (interactive prompt) to generate an API key for Nessus and save to .nessus.yml"
  option :home, :type => :string, :default => ENV['HOME'], :desc => 'Home directory location for credentials file'
  option :yes, :aliases => '-y', :type => :boolean, :desc => 'Skip prompts for confirmation'
  def get_api_key(nessus_url)
     uri = URI(nessus_url)
     fail("You nees to use a https:// URL for Nessus") unless uri.scheme == 'https'
     creds_file = File.join(options[:home], '.nessus.yml')
     if File.exist?(creds_file) && !options[:yes]
       confirm = ask("Overwrite existing file #{creds_file} ?", :yellow, limited_to: ['yes', 'no'], :default => 'yes')
       if confirm != 'yes'
         say("Aborting command", :red)
         exit
       end
     end
     username = ask("username:")
     password = ask("password:", :echo => false)
     say('********')
     session = NessusClient::Session.create(nessus_url, username, password)
     keys = session.keys
     keys = {'url' => nessus_url}.merge(keys)
     File.write(creds_file, keys.to_yaml)
     say("New API keys written to #{creds_file}")
     session.destroy
  end
end

begin
  Nessus.start
rescue => e
  puts "ERROR - " + e.message
  puts e.backtrace.first
  exit(1)
end
